/**
 * EJEMPLO: C√≥mo usar el CentroLogging en servicios existentes
 *
 * El sistema de logging ya est√° integrado globalmente en tu aplicaci√≥n:
 * - El interceptor LoggingInterceptor captura todos los requests/responses autom√°ticamente
 * - El Global Exception Filter captura todos los errores autom√°ticamente
 * - El TypeORM Subscriber audita autom√°ticamente cambios en entidades
 *
 * Para usar logging adicional en tus servicios, sigue estos ejemplo:
 */

// ============================================================================
// EJEMPLO 1: Usar LoggingService en un servicio
// ============================================================================

import { Injectable } from '@nestjs/common';
import { LoggingService } from 'src/logs/services/logging.service';
import { LogContext } from 'src/logs/types/log.types';

@Injectable()
export class MiServicio {
  constructor(private loggingService: LoggingService) {}

  async procesarAlgo(): Promise<void> {
    // Contexto b√°sico (sin request)
    const context: LogContext = {
      requestId: this.loggingService.generateRequestId(),
      userId: 123,
      timestamp: new Date(),
    };

    // Loguear informaci√≥n
    await this.loggingService.log('Iniciando procesamiento', context, {
      datos: 'adicionales',
    });

    try {
      // ... l√≥gica del negocio
    } catch (error) {
      // Loguear error
      await this.loggingService.error('Error en procesamiento', context, error, {
        paso: 'paso donde fall√≥',
      });
    }
  }
}

// ============================================================================
// EJEMPLO 2: Usar LoggingService en un controlador con contexto de request
// ============================================================================

import { Controller, Post, Req, Body } from '@nestjs/common';
import { Request } from 'express';

@Controller('mi-endpoint')
export class MiControlador {
  constructor(private loggingService: LoggingService) {}

  @Post('crear')
  async crear(@Req() req: Request, @Body() dto: any): Promise<any> {
    // LoggingInterceptor ya ha generado un requestId
    const context = this.loggingService.createHttpContext(req, {
      timestamp: new Date(),
    });

    await this.loggingService.log('Creando recurso', context, {
      tipoRecurso: dto.tipo,
    });

    // ... l√≥gica
  }
}

// ============================================================================
// EJEMPLO 3: Acceder a logs desde el controlador
// ============================================================================

import { Injectable } from '@nestjs/common';
import { LogsQueryService } from 'src/logs/services/logs-query.service';
import { FilterLogsDto } from 'src/logs/dtos/log.dto';

// Endpoint disponible: GET /api/v1/logs
// Ejemplo de solicitud:
// GET /api/v1/logs?level=error&userId=123&limit=50&page=1

// O acceder program√°ticamente:
@Injectable()
export class OtroServicio {
  constructor(private logsQueryService: LogsQueryService) {}

  async obtenerErroresDelUsuario(userId: number): Promise<any> {
    return this.logsQueryService.getLogs({
      userId,
      level: 'error',
      limit: 100,
      page: 1,
      sortBy: 'createdAt',
      order: 'DESC',
    });
  }

  async obtenerLogsPorRequestId(requestId: string): Promise<any> {
    return this.logsQueryService.getLogsByRequestId(requestId);
  }
}

// ============================================================================
// ENDPOINTS DISPONIBLES
// ============================================================================

/*
  LOGS:
  - GET /api/v1/logs                    - Listar logs con filtros
  - GET /api/v1/logs/:requestId         - Obtener todos los logs de un request
  - GET /api/v1/logs/stats/by-level     - Estad√≠sticas por nivel
  - GET /api/v1/logs/stats/errors-by-endpoint - Errores por endpoint
  
  AUDIT (Cambios en entidades):
  - GET /api/v1/logs/audit/list         - Listar cambios de entidades
  - GET /api/v1/logs/audit/stats        - Estad√≠sticas de cambios por entidad

  PAR√ÅMETROS DE FILTRO:
  - page: n√∫mero (default 1)
  - limit: n√∫mero (default 20)
  - level: 'log' | 'debug' | 'warn' | 'error'
  - userId: n√∫mero
  - endpoint: string (b√∫squeda parcial)
  - method: GET | POST | PUT | DELETE
  - search: string (busca en message)
  - startDate: ISO date string
  - endDate: ISO date string
  - sortBy: 'createdAt' | 'level' | 'userId' (default createdAt)
  - order: 'ASC' | 'DESC' (default DESC)
*/

// ============================================================================
// COMPORTAMIENTO AUTOM√ÅTICO
// ============================================================================

/*
  1. INTERCEPTOR HTTP (LoggingInterceptor):
     - Captura cada request/response
     - Registra duraci√≥n, status code, IP, user agent
     - Genera request ID √∫nico para correlacionar logs
     - NO bloquea el flujo del endpoint
  
  2. GLOBAL EXCEPTION FILTER (GlobalExceptionFilter):
     - Captura errores no manejados
     - Registra stack trace autom√°ticamente
     - Responde al cliente con error formateado
  
  3. AUDIT SUBSCRIBER (AuditSubscriber):
     - Escucha INSERT, UPDATE, DELETE de TypeORM
     - Registra cambios (before/after)
     - Captura usuario y storeId si est√°n disponibles
     - Excluye cambios no relevantes (timestamps, deleted_at)
*/

// ============================================================================
// CONSIDERACIONES DE PERFORMANCE
// ============================================================================

/*
  ‚úÖ Logs se procesan en background sin bloquear requests
  ‚úÖ Bull/BullMQ maneja reintentos autom√°ticos
  ‚úÖ LogsPersistenceService agrupa logs en batch (default 100)
  ‚úÖ Flush peri√≥dico cada 5 segundos
  ‚úÖ √çndices optimizados en BD para b√∫squedas r√°pidas
  
  üìä Con 100k-1M requests/d√≠a:
     - Throughput: ~10-1000 logs/segundo
     - Latencia agregada: <5ms por request
     - Espacio en BD: ~500 bytes por log (~500GB/a√±o)
*/

// ============================================================================
// VARIABLES DE ENTORNO
// ============================================================================

/*
  # .env
  LOG_LEVEL=log              # Nivel m√≠nimo a registrar
  LOG_RETENTION_DAYS=90      # D√≠as a mantener en BD
  LOG_BATCH_SIZE=100         # Logs por batch
  LOG_BATCH_TIMEOUT_MS=5000  # ms entre flushes
  BULL_QUEUE_NAME=logs       # Nombre de la queue
  BULL_MAX_WORKERS=4         # Workers concurrentes
*/
